import React, { useState } from "react";
import { useTranslation } from "react-i18next";
import { chunked } from "../Utils";
import Forms from "./Forms";
import Preview from "./Preview";
import templateJSON from "../json/template.json";
import "./Editor.css";

type Props = {
  lang: string;
  owner: string | null;
  repo: string | null;
  autoFill: boolean;
};

type Attributes = {
  kindsOfFile?: string[];
  placeholder?: string;
  maxLength?: number;
};

type Decoration = {
  title: string;
  description: string;
  required: boolean;
  formType: string;
  attributes: Attributes;
};

type Section = {
  title: string;
  description: string;
  required: boolean;
  multiple: boolean;
  hiddenTitle: boolean;
  replacingTitle: boolean;
  formType: string;
  kindsOfValues: string[];
  formats: string[];
  attributes: Attributes;
  script: string;
};

type Template = {
  decorations: Decoration[];
  sections: Section[];
};

type SectionState = {
  section: Section;
  values: string[];
  files: (File | null)[];
};

export type EditorState = {
  showAlert: boolean;
  sectionStates: SectionState[];
};

/*
一旦decorationsは無視

Previewの仕組み
・入力データからjson（object）を作る
　・titleを抽出
　・valuesを抽出（実際のvalueとkindsOfValuesがあればあとで構成できそう）
・jsonからMarkdown文を生成

Downloadの仕組み
・kindsOfValuesにfilePathが含まれているかどうか
・含まれていたらそれだけを抽出してArrayにする -> file-${index}でリネームして出力
*/

export default function Editor(props: Props) {
  const { lang, owner, repo, autoFill } = props;
  const { t } = useTranslation();
  const initialState: EditorState = {
    showAlert: false,
    sectionStates: (templateJSON as Template).sections.map(
      (section): SectionState => ({
        section: section,
        values: Array(section.kindsOfValues.length || 1).fill(""),
        files: [null],
      })
    ),
  };
  const [editorState, setEditorState] = useState(initialState);

  const setValues = (at: number, values: string[]) => {
    setEditorState({
      ...editorState,
      sectionStates: editorState.sectionStates.map((sectionState, index): SectionState => {
        if (index === at) {
          return {
            ...sectionState,
            values: values,
          };
        } else {
          return sectionState;
        }
      }),
    });
  };

  const setFiles = (at: number, values: string[], files: (File | null)[]) => {
    setEditorState({
      ...editorState,
      sectionStates: editorState.sectionStates.map((sectionState, index): SectionState => {
        if (index === at) {
          return {
            ...sectionState,
            values: values,
            files: files,
          };
        } else {
          return sectionState;
        }
      }),
    });
  };

  const generateReadme = (output: boolean) => {
    const text = editorState.sectionStates.reduce((result, sectionState) => {
      const { title, hiddenTitle, replacingTitle, kindsOfValues, formats } = sectionState.section;
      let text = "";
      const isEmpty =
        sectionState.values.reduce((result, value) => {
          return result + value.length;
        }, 0) === 0;
      if (isEmpty) {
        return result;
      }
      const hasFile = sectionState.section.attributes.kindsOfFile !== undefined;
      const valueText = chunked(sectionState.values, kindsOfValues.length)
        .reduce((result, values, i) => {
          const formatedText = formats.reduce((result, format, j) => {
            if (values[j].length > 0) {
              if (output && hasFile) {
                const extension = sectionState.files[i]?.name.split(".").pop() || "";
                const path = `resources/file-${i}-${j}.${extension}`;
                return result + format.replace("%s", path);
              } else {
                return result + format.replace("%s", values[j]);
              }
            } else {
              return result;
            }
          }, "");
          return result + formatedText;
        }, "")
        .trimEnd();
      if (hiddenTitle === false) {
        if (replacingTitle) {
          text += `# ${valueText}\n`;
        } else {
          text += `# ${title}\n\n`;
          text += `${valueText}\n`;
        }
      } else {
        text += `<!-- # ${title} -->\n\n`;
        text += `${valueText}\n`;
      }
      text += "\n";
      return result + text;
    }, "");
    return text + "<!-- CREATED_BY_LEADYOU_README_GENERATOR -->";
  };

  return (
    <div className="editor">
      <div className="edit-area">
        <h2>Input Form</h2>
        <div className="edit-inner">
          <form>
            <Forms editorState={editorState} setValues={setValues} setFiles={setFiles} />
            <p className="proviso">
              {"If you generate a README, you are deemed to have accepted the "}
              <a href="?scene=document&pageid=terms-of-service">Terms of Service</a>
              {". "}
              {
                "And if you upload README that is generated by LEADYOU to your public repository on GitHub, it will be on "
              }
              <a href="/">New Generated READMEs</a>
              {". "}
              {"If you do not want it, please refer "}
              <a href="?scene=document&pageid=help">Help</a>
              {" page."}
            </p>
            <input type="submit" value="Generate" />
            {editorState.showAlert && <p className="fill-alert"></p>}
          </form>
        </div>
      </div>
      <div className="preview-area">
        <h2>Preview README</h2>
        <div className="md-content">
          <Preview markdownText={generateReadme(false)} />
        </div>
      </div>
    </div>
  );
}
